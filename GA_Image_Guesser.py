# -*- coding: utf-8 -*-
"""ImageGA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tAcR3zS1nmKqHmMEqcqTc56KjlNmz61P
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt
from IPython.display import Image
from google.colab.patches import cv2_imshow
import scipy
import random
from scipy.spatial import distance
import copy

def matricize(array):
  return np.reshape(array, (10,10))

def linearize(array):
  return np.reshape(array, 100)

image = cv2.imread('Sample-image.jpg')

#print(image.shape)
# cv2_imshow(image)

height = int(10)
width = int(10)
dimension = (width, height)

resized_image = cv2.resize(image, dimension, interpolation=cv2.INTER_AREA)

print(resized_image.shape)
cv2_imshow(resized_image)

grayscale_image = cv2.cvtColor(resized_image, cv2.COLOR_BGR2GRAY)
print(grayscale_image.shape)
cv2_imshow(grayscale_image)

array_image = np.asarray(grayscale_image)
print(array_image)
print(array_image.shape)
len(array_image)

linearized_image = copy.deepcopy(linearize(array_image))
print(linearized_image)
print(linearized_image.shape)
len(linearized_image)
print("Min = ", min(linearized_image))
print("Max = ", max(linearized_image))

matricized_image = copy.deepcopy(matricize(linearized_image))
print(matricized_image)
print(matricized_image.shape)
cv2_imshow(matricized_image)

random_image = np.random.randint(10, 203, size=100)
print(random_image)
matricized_random_image = copy.deepcopy(matricize(random_image))
print(matricized_random_image)
print(matricized_random_image.shape)
len(matricized_random_image)
cv2_imshow(matricized_random_image)
print("Min = ", min(random_image))
print("Max = ", max(random_image))

scipy.spatial.distance.hamming(random_image, linearized_image)

copy = copy.deepcopy(linearized_image)
scipy.spatial.distance.hamming(copy, linearized_image)

pop_size = 100
generations = 10000
mutation_ratio = 0.008

def initialization():
  population = []
  for k in range(0, pop_size):
    rnd_img = np.random.randint(10, 203, size=100)
    population.append(rnd_img)
  return population

initialization()

# This works properly
def find_fittest_member(fitnesses):
  index = 0
  fittest = fitnesses[0]
  for j in range(1, len(fitnesses)):
    if fitnesses[j] > fittest:
      fittest = fitnesses[j]
      index = j
  return index

def find_SecondFittest_member(pop):
  fit_index = find_fittest_member(pop)
  fit = pop[fit_index]
  index = 0
  fittest = pop[0]
  for j in range(1, len(pop)):
    if pop[j] > fittest and pop[j] < fit :
      fittest = pop[j]
      index = j
  return index

# This works properly
def find_LeastFit_member(pop):
  index = 0
  fittest = pop[0]
  for j in range(1, len(pop)):
    if pop[j] < fittest:
      fittest = pop[j]
      index = j
  return index

# This works properly but it is incomplete
def breeding(population, selection_probabilities):
    parents = []
    if np.random.uniform(0, 1) < 0.5:
        while len(parents) < 1:
            for k in range(0, len(population)):
                if selection_probabilities[k] > np.random.uniform(0, 1) and len(parents) < 1:
                    parents.append(population[k])
        new_child = mutate(parents[0])
    else:
        while len(parents) < 2:
            for h in range(0, len(population)):
                if selection_probabilities[h] > np.random.uniform(0, 1) and len(parents) < 2:
                    parents.append(population[h])
        new_child = crossover(parents)
    return new_child

def crossover(parent):
  
#   parent_one = copy.deepcopy(parent[0])
#   parent_two = copy.deepcopy(parent[1])

  parent_one = parent[0].copy()
  parent_two = parent[1].copy()
  
  child = [None] * len(parent_one)
  
  for p in range(0, len(child)):
    if np.random.uniform(0, 1) < 0.5:
      child[p] = parent_one[p]
    else:
      child[p] = parent_two[p]
  
#   print("crossover happend")
  return child

def crossover2(parent):
  
  parent_one = copy.deepcopy(parent[0])
  parent_two = copy.deepcopy(parent[1])
  
  child = [None] * len(parent_one)
  
  for p in range(0, int(len(child)/2)):
    child[p] = parent_one[p]
    
  for p in range(int(len(child)/2)+1, len(child)):
    child[p] = parent_two[p]
  
#   print("crossover happend")
  return child

# I think this works properly (prone to diuble-check)
def mutate(parent):
  
#   mutated_parent = copy.deepcopy(parent)

  mutated_parent = parent.copy()  
  number_of_mutated_elemnts = int(len(parent)*mutation_ratio)
  
  indices_of_mutated_elements = random.sample(range(11, 201), number_of_mutated_elemnts)
  
  for index in indices_of_mutated_elements:
    rnd = np.random.randint(11, 201)
    mutated_parent[index] = rnd
  
#   print("mutation happend")
  return mutated_parent

population = initialization()
# print(population)
fitnesses = [None] * pop_size
selection_probabilities = [None] * pop_size

for g in range(0, generations):
  print("Generation ", g+1)
  
  count = 0
  for member in population:
    distance = scipy.spatial.distance.hamming(member, linearized_image)
    fitnesses[count] = 1 - distance
    count = count + 1
#   print(fitnesses)
  
  for i in range(0 , len(fitnesses)):
    selection_probabilities[i] = fitnesses[i] / np.sum(fitnesses)
#   print(selection_probabilities)
  
  child = breeding(population, selection_probabilities)
  
  child_fitness = 1- scipy.spatial.distance.hamming(child, linearized_image)
  shit_index = find_LeastFit_member(fitnesses)
  shit_fitness = fitnesses[shit_index]
  
  if child_fitness > shit_fitness:
    fitnesses[shit_index] = child_fitness
    population[shit_index] = child
    
#   print("Child fitness = ", child_fitness)
#   matricized_child = matricize(child).copy()
#   cv2_imshow(matricized_child)
#   print(fitnesses)
#   print(population)
#   print(selection_probabilities)
  fittest_index = find_fittest_member(fitnesses)
#   print(fittest_index)
  print("Top fitness = ", fitnesses[fittest_index])
#   matricized_top = matricize(population[fittest_index]).copy()
#   cv2_imshow(matricized_top)
#   shit_index = find_LeastFit_member(fitnesses)
#   print(fitnesses[shit_index])

